@page "/search"
@using Microsoft.Extensions.AI
@using MihuBot.DB.GitHub
@using MihuBot.RuntimeUtils
@using Octokit
@rendermode InteractiveServer
@inject GitHubDataService GitHubData
@inject GitHubSearchService Search
@inject HybridCache Cache
@inject OpenAIService OpenAI
@inject Logger Logger
@inject IConfigurationService Configuration
@implements IDisposable

<PageTitle>GitHub Search</PageTitle>

<style>
    .search-toolbar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
    }

    .toolbar-center {
        display: flex;
        justify-content: center;
        flex-grow: 2;
    }

    .loading-progress-container {
        width: 100%;
        height: 8px;
    }

    .loading-progress-bar {
        height: 8px;
        background: #04AA6D;
    }

    #searchQuery {
        width: clamp(35vw, 200px, 500px);
        font-size: 22px;
    }

    .statistics-container {
        margin-left: auto;
    }

    .issue-icon {
        display: inline-block;
        width: 16px;
        height: 16px;
        margin-bottom: -2px;
    }
</style>

<div>
    <div class="search-toolbar">
        <div class="toolbar-center">
            <div class="form-group">
                <div class="input-group">
                    <input id="searchQuery" type="text" @bind-value="SearchQuery" @bind-value:event="oninput" placeholder="Search query">
                    <div class="btn-group" role="group">
                        <button type="button" @onclick="() => DisableRelevanceClassification = !DisableRelevanceClassification" class="btn btn-primary ml-1">@(DisableRelevanceClassification ? "Filter unrelated results" : "I want faster searches")</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="statistics-container">
            <p>@(GitHubData.IssueCount / 1_000)k issues, @(GitHubData.CommentCount / 1_000)k comments, @(GitHubData.SearchVectorCount / 1_000)k vectors</p>
        </div>
    </div>

    <div class="loading-progress-container">
        <div class="loading-progress-bar" id="loadingProgressBar" style="width: @(_isLoading ? "100" : "0")%"></div>
    </div>

    @if (_errorMessage is not null)
    {
        <div class="alert alert-danger">
            @_errorMessage
        </div>
    }

    @if (_searchResults.Length == 0)
    {
        <div class="alert alert-info">
            No results found.
        </div>
    }
    else
    {
        <div class="list-group">
            @foreach (var result in _searchResults)
            {
                <a href="@result.Issue.HtmlUrl" class="list-group-item list-group-item-action">
                    <div>
                        <span class="issue-icon @PickCssIconClass(result.Issue)" aria-hidden="true"></span>
                        <span class="mb-1">@result.Issue.Title.TruncateWithDotDotDot(300)</span>
                    </div>
                    <div>
                        <span class="mr-1">@result.Score.ToString("F2")</span>
                        <span class="ml-1 mr-1">@result.Issue.CreatedAt.ToISODate()</span>
                        <span class="ml-1 mr-1">#@result.Issue.Number by @result.Issue.User.Login</span>
                        @foreach (var label in result.Issue.Labels)
                        {
                            <span class="badge badge-pill ml-1" style="background-color: #@label.Color; color: @PickCssTextColor(label.Color)">@label.Name</span>
                        }
                    </div>
                </a>
            }
        </div>
    }
</div>

@code
{
    static string PickCssTextColor(string backgroundColor)
    {
        // https://stackoverflow.com/a/36888120/6845657
        var color = Color.Parse(backgroundColor);
        double luma = ((0.299 * color.R) + (0.587 * color.G) + (0.114 * color.B)) / 255;
        return luma > 0.5 ? "black" : "white";
    }

    static string PickCssIconClass(IssueInfo issue)
    {
        if (issue.PullRequest is { } pr)
        {
            return issue.State == ItemState.Open
                ? pr.Draft ? "icon-pr-opened-draft" : "icon-pr-opened"
                : pr.MergedAt.HasValue ? "icon-pr-merged" : "icon-pr-closed";
        }

        return issue.State == ItemState.Open
            ? "icon-issue-opened"
            : "icon-issue-closed";
    }

    private IChatClient _fastClassifierChat;
    private (IssueInfo Issue, double Score)[] _searchResults = [];
    private string _errorMessage;
    private Debouncer<(string Query, bool DsableRelevanceClassification)> _debouncer;
    private bool _isLoading;

    private bool DisableRelevanceClassification
    {
        get => field;
        set
        {
            field = value;
            RefreshSearchResults();
        }
    }

    private string SearchQuery
    {
        get => field;
        set
        {
            field = value;
            RefreshSearchResults();
        }
    }

    private void RefreshSearchResults()
    {
        _debouncer.Update((SearchQuery.Trim(), DisableRelevanceClassification));
    }

    protected override void OnInitialized()
    {
        Configuration.TryGet(null, "GitHubSearch.ClassifierModel", out string modelName);
        _fastClassifierChat = OpenAI.GetChat(modelName ?? "gpt-4.1-mini");
        _debouncer = new Debouncer<(string, bool)>(TimeSpan.FromMilliseconds(25), SearchAsync);
        _debouncer.CancelPendingActions = true;
    }

    private async Task SearchAsync((string SearchQuery, bool DisableRelevanceClassification) state, CancellationToken cancellationToken)
    {
        (string searchQuery, bool disableRelevanceClassification) = state;

        try
        {
            if (searchQuery.Length > 1_000)
            {
                _errorMessage = "Stop it";
            }
            else
            {
                if (string.IsNullOrWhiteSpace(searchQuery))
                {
                    _searchResults = [];
                }
                else
                {
                    _isLoading = true;

                    var searchTask = Search.SearchIssuesAndCommentsAsync(searchQuery, maxResults: 200, cancellationToken);
                    await InvokeAsync(StateHasChanged);

                    (GitHubSearchService.IssueSearchResult[] Results, double Score)[] resultsByIssue = (await searchTask)
                        .GroupBy(r => r.Issue.Id)
                        .Select(g => g.ToArray())
                        .Select(r => (Results: r, Score: GetCombinedScore(r)))
                        .OrderByDescending(p => p.Score)
                        .Take(100)
                        .ToArray();

                    if (!disableRelevanceClassification)
                    {
                        resultsByIssue = await FilterOutUnrelatedResults(searchQuery, resultsByIssue, cancellationToken);
                    }

                    _searchResults = resultsByIssue
                        .Select(r => (r.Results[0].Issue, r.Score))
                        .ToArray();
                }

                _errorMessage = null;
                _isLoading = false;
            }
        }
        catch (Exception ex)
        {
            if (cancellationToken.IsCancellationRequested)
            {
                return;
            }

            _errorMessage = ex.Message;
        }

        try
        {
            await InvokeAsync(StateHasChanged);
        }
        catch { }

        static double GetCombinedScore(GitHubSearchService.IssueSearchResult[] results)
        {
            double max = results.Max(r => r.Score);
            double offset = 1 - max;

            // Boost issues with multiple potentially related comments.
            double threshold = Math.Max(max * 0.75, 0.35);
            offset *= Math.Pow(0.99, results.Count(r => r.Score >= threshold));

            return 1 - offset;
        }
    }

    private async Task<(GitHubSearchService.IssueSearchResult[] Results, double Score)[]> FilterOutUnrelatedResults(
        string searchQuery, (GitHubSearchService.IssueSearchResult[] Results, double Score)[] results, CancellationToken cancellationToken)
    {
        searchQuery = searchQuery.Trim();

        var relevances = await GetRelevancesAsync(issueCount: 20, bodyContext: 40, maxComments: 2);

        if (relevances.Length <= 5 && results.Length >= 20)
        {
            relevances = await GetRelevancesAsync(issueCount: 50, bodyContext: 100, maxComments: 4);
        }

        var newResults = relevances
            .Select(s =>
            {
                var searchResult = results.FirstOrDefault(r => r.Results[0].Issue.Number == s.IssueNumber);
                return searchResult.Results is null ? default : searchResult with { Score = s.Score };
            })
            .Where(r => r.Results is not null)
            .OrderByDescending(r => r.Score)
            .ToArray();

        return newResults.Length > 0 ? newResults : results;

        async Task<IssueRelevance[]> GetRelevancesAsync(int issueCount, int bodyContext, int maxComments)
        {
            return await Cache.GetOrCreateAsync($"/searchrelevance/{results.Length}-{issueCount}-{bodyContext}-{maxComments}/{searchQuery.GetUtf8Sha384HashBase64Url()}", async _ =>
            {
                Stopwatch stopwatch = Stopwatch.StartNew();

                var relevances = await _fastClassifierChat.GetResponseAsync<IssueRelevance[]>(GeneratePrompt(issueCount, bodyContext, maxComments), cancellationToken: CancellationToken.None);

                Logger.DebugLog($"Relevance classification for '{searchQuery}' took {stopwatch.ElapsedMilliseconds:F2} ms for {Math.Min(issueCount, results.Length)} issues");

                return relevances.Result
                    .Where(s => s.Score > 0.1)
                    .ToArray();
            }, cancellationToken: CancellationToken.None).WaitAsyncAndSupressNotObserved(cancellationToken);
        }

        string GeneratePrompt(int issueCount, int bodyContext, int maxComments)
        {
            return
                $"""
                Classify the relevance of the following GitHub issues based on the search query "{searchQuery}".
                Specify the approximate relevance score from 0 to 1 for each issue, where 0 means not relevant and 1 means very relevant.
                If an issue is unlikely to be relevant, set the score to 0.
                Return the set of issue numbers with their relevance scores.

                Prefer faster responses over accuracy.

                The issues are:

                {string.Join("\n\n\n---\n\n\n", results.Take(issueCount).Select(r => GetShortIssueDescription(r.Results, bodyContext, maxComments)))}
                """;
        }

        string GetShortIssueDescription(GitHubSearchService.IssueSearchResult[] results, int bodyContext, int maxComments)
        {
            IssueInfo issue = results[0].Issue;

            StringBuilder sb = new();

            sb.AppendLine($"Issue #{issue.Number}: {issue.Title}");

            if (issue.Labels.FirstOrDefault(l => l.Name.StartsWith("area-", StringComparison.OrdinalIgnoreCase))?.Name is { } areaLabel)
            {
                sb.AppendLine($"Area: {areaLabel.AsSpan(5)}");
            }

            string body = TrimBody(issue.Body, bodyContext);

            if (!string.IsNullOrEmpty(body))
            {
                sb.AppendLine($"Body: {body}");
            }

            foreach (var result in results
                .Where(r => r.Score >= 0.25 && r.Comment is not null)
                .OrderByDescending(r => r.Score)
                .Take(maxComments))
            {
                sb.AppendLine($"Comment: {TrimBody(result.Comment.Body, bodyContext)}");
            }

            return sb.ToString();

            string TrimBody(string body, int bodyContext)
            {
                if (string.IsNullOrEmpty(body))
                {
                    return string.Empty;
                }

                body = SemanticMarkdownChunker.TrimTextToTokens(Search.Tokenizer, body, bodyContext);

                while (body.Contains("\n\n\n", StringComparison.Ordinal))
                    body = body.Replace("\n\n\n", "\n\n", StringComparison.Ordinal);

                while (body.Contains("--", StringComparison.Ordinal))
                    body = body.Replace("--", "-", StringComparison.Ordinal);

                return body.Trim();
            }
        }
    }

    public void Dispose() => _debouncer?.Dispose();

    private record IssueRelevance(int IssueNumber, double Score);
}
