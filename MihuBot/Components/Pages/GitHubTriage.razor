@page "/triage"
@using Markdig
@using Markdig.Syntax
@using Microsoft.EntityFrameworkCore
@using Microsoft.Extensions.AI
@using MihuBot.DB.GitHub
@using MihuBot.RuntimeUtils
@using Octokit
@using System.ComponentModel
@using System.Collections.Concurrent
@rendermode InteractiveServer
@inject GitHubSearchService GitHubSearchService
@inject IDbContextFactory<GitHubDbContext> GitHubDb
@inject GitHubClient GitHubClient
@inject OpenAIService OpenAIService
@inject RuntimeUtilsService RuntimeUtils
@inject Logger Logger
@implements IDisposable

<PageTitle>GitHub Triage</PageTitle>

<style>
    .search-toolbar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        width: 100%;
    }

    .toolbar-center {
        display: flex;
        justify-content: center;
        flex-grow: 2;
    }

    .loading-progress-container {
        width: 100%;
        height: 8px;
    }

    .loading-progress-bar {
        height: 8px;
        background: #04AA6D;
    }

    #triageIssueUrl {
        width: clamp(35vw, 200px, 500px);
        font-size: 22px;
    }
</style>

<AuthorizeView Policy="GitHub">
    <Authorized>
        @if (_hasRuntimeUtilsPermissions)
        {
            <div>
                <div class="search-toolbar">
                    <div class="toolbar-center">
                        <div class="form-group">
                            <div class="input-group">
                                <input id="triageIssueUrl" type="text" @bind-value="TriageIssueUrl" @bind-value:event="oninput" placeholder="Issue/PR (number or link)">
                                <div class="input-group-append ml-1">
                                    <button class="btn btn-outline-info dropdown-toggle" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">@Model.Name</button>
                                    <div class="dropdown-menu">
                                        @foreach (var model in s_availableModels)
                                        {
                                            <a class="dropdown-item" @onclick="() => Model = model">@model.Name</a>
                                        }
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="loading-progress-container">
                    <div class="loading-progress-bar" id="loadingProgressBar" style="width: @(_loading ? "100" : "0")%"></div>
                </div>

                @if (_errorMessage is not null)
                {
                    <div class="alert alert-danger">
                        @_errorMessage
                    </div>
                }

                <pre style="max-width: 95%; max-height: 95vh; overflow: hidden; display: flex;">
                    <code style="word-wrap: break-word; font-size: small">
                        @foreach (string line in _toolLogs)
                        {
                            @line
                        }
                    </code>
                </pre>

                @((MarkupString)_htmlResponse)
            </div>
        }
        else
        {
            <p>Ask @@MihaZupan to grant you access.</p>
        }
    </Authorized>
    <NotAuthorized>
        <a href="Account/Login/GitHub?returnUrl=triage">
            <img src="github-mark.svg" />
            <strong style="font-size: 24px">Login with GitHub</strong>
        </a>
    </NotAuthorized>
</AuthorizeView>

@code
{
    private const string SystemPrompt =
        """
        You are an assistant helping the .NET team triage new GitHub issues in the https://github.com/dotnet/runtime repository.
        You are provided with information about a new issue and you need to find related issues or comments among the existing GitHub data.

        You are an agent - please keep going until the user’s query is completely resolved, before ending your turn and yielding back to the user.
        Assume that the user will NOT be able to reply and ask futher, more refined questions. You MUST iterate and keep going until you have all the information.
        Only terminate your turn when you are sure that the problem is solved.
        Your thinking should be thorough and so it's fine if it's very long. You can think step by step before and after each action you decide to take.

        Use tools to find issues and comments that may be relevant. It is up to you to determine whether the results are relevant.
        Be thorough with your searches and always consider the full discussion on related issues. You should perform as many searches as needed{{MAX_SEARCH_COUNT}}.
        Tools use semantic searching to find issues and comments that may be relevant to the issue you are triaging. You can search for multiple terms at the same time.

        When evaulating an issue, always use tools to ask for the FULL history of comments on that issue.
        Even if you've seen previous comments from an issue, you haven't seen all of them unless you've called the full history for that specific issue.
        Use your tools to gather the relevant information from comments: do NOT guess or make up conclusions for a given issue.
        Pay close attention to comments when summarizing the issue as questions may have already been answered.

        Reply with a list of related issues and include a short summary of the discussions/conclusions for each one.
        Assume that the user is familiar with the repository and its processes, but not necessarily with the specific issue or discussion.

        Reply in GitHub markdown format.
        """;

    private static readonly HashSet<string> s_networkingTeam = new(
        ["MihaZupan", "CarnaViire", "karelz", "antonfirsov", "ManickaP", "wfurt", "rzikm", "liveans", "rokonec"],
        StringComparer.OrdinalIgnoreCase);

    private record ModelInfo(string Name, int ContextSize, bool SupportsTemperature);

    private const string DefaultModel = "gpt-4.1";
    private static readonly ModelInfo[] s_availableModels = [new("gpt-4.1", 1_000_000, true), new("o4-mini", 200_000, false)];

    private string _errorMessage;
    private readonly ConcurrentQueue<string> _toolLogs = new();
    private string _htmlResponse;

    private readonly object _lock = new();
    private (string TriageIssueUrl, ModelInfo Model) _currentTriage;
    private CancellationTokenSource _currentTriageCts;
    private Task _currentTriageTask = Task.CompletedTask;
    private IssueInfo _currentIssue;
    private bool _loading;

    [CascadingParameter]
    private Task<AuthenticationState> _authenticationState { get; set; }
    private string _githubUserLogin;
    private bool _hasRuntimeUtilsPermissions;

    private bool UsingLargeContextWindow => Model.ContextSize >= 500_000;

    private string TriageIssueUrl
    {
        get => field;
        set
        {
            field = value;
            UpdateTriageOperation();
        }
    }

    private ModelInfo Model
    {
        get => field ??= s_availableModels.First(m => m.Name == DefaultModel);
        set
        {
            field = value;
            UpdateTriageOperation();
        }
    }

    protected override async Task OnInitializedAsync()
    {
        if (_authenticationState is not null &&
            (await _authenticationState).User.TryGetGitHubLogin(out _githubUserLogin))
        {
            _hasRuntimeUtilsPermissions = RuntimeUtils.CheckGitHubUserPermissions(_githubUserLogin);
        }
    }

    private void UpdateTriageOperation()
    {
        lock (_lock)
        {
            string triageIssueUrl = TriageIssueUrl;
            ModelInfo model = Model;

            if (_currentTriage.TriageIssueUrl == triageIssueUrl && _currentTriage.Model == model)
            {
                return;
            }

            _currentTriage = default;

            if (_currentTriageCts is not null)
            {
                _currentTriageCts.Cancel();
                _currentTriageCts = null;
            }

            _currentTriage = (triageIssueUrl, model);
            _currentTriageCts = new CancellationTokenSource();

            CancellationToken cancellationToken = _currentTriageCts.Token;

            var currentTask = _currentTriageTask;
            _currentTriageTask = Task.Run(async () =>
            {
                await currentTask;
                _loading = true;
                await DoTriageAsync(triageIssueUrl, model, cancellationToken);
                _loading = false;
                await InvokeAsync(StateHasChanged);
            });
        }
    }

    private void LogToolLine(string message)
    {
        _toolLogs.Enqueue($"{message}\n");
        _ = InvokeAsync(StateHasChanged);
    }

    private async Task DoTriageAsync(string triageIssueUrl, ModelInfo model, CancellationToken cancellationToken)
    {
        try
        {
            _errorMessage = null;
            _htmlResponse = null;
            _toolLogs.Clear();

            if (string.IsNullOrEmpty(triageIssueUrl))
            {
                return;
            }

            ArgumentOutOfRangeException.ThrowIfNotEqual(_hasRuntimeUtilsPermissions, true);

            if (!GitHubHelper.TryParseIssueOrPRNumber(triageIssueUrl, dotnetRuntimeOnly: true, out int issueNumber))
            {
                _errorMessage = "Invalid issue/PR URL. Use the number or the full link.";
                return;
            }

            LogToolLine($"Starting triage for issue #{issueNumber} with model {model.Name} ...");

            IssueInfo issue = await GetIssueAsync(issueNumber, includeComments: true, cancellationToken);

            if (issue is null)
            {
                Logger.DebugLog($"Triage: Issue #{issueNumber} not found in the database. Fetching from GitHub ...");

                Issue newIssue = await GitHubClient.Issue.Get("dotnet", "runtime", issueNumber);
                if (newIssue is null)
                {
                    _errorMessage = $"Issue #{issueNumber} not found.";
                    return;
                }
                else
                {
                    issue = new IssueInfo();
                    GitHubDataService.PopulateBasicIssueInfo(issue, newIssue);
                    issue.User = new UserInfo
                    {
                        Id = newIssue.User.Id,
                        Login = newIssue.User.Login,
                    };
                    issue.Comments = [];
                }
            }

            _currentIssue = issue;
            Logger.DebugLog($"Starting triage for {issue.HtmlUrl} with model {model.Name} for {_githubUserLogin}");

            LogToolLine($"{issue.Title} by {issue.User.Login}");

            var options = new ChatOptions
            {
                Tools =
                [
                    AIFunctionFactory.Create(Search),
                    AIFunctionFactory.Create(GetIssueCommentHistory),
                ],
                ToolMode = ChatToolMode.RequireAny
            };

            if (model.SupportsTemperature)
            {
                options.Temperature = 0;
            }

            string systemPrompt = SystemPrompt
                .Replace("{{MAX_SEARCH_COUNT}}", UsingLargeContextWindow ? "" : " (max of 5)", StringComparison.Ordinal);

            List<ChatMessage> messages = [new ChatMessage(ChatRole.System, systemPrompt)];

            messages.Add(new ChatMessage(ChatRole.User,
                $"""
                Please help me triage issue #{issue.Number} from {issue.User.Login} titled '{issue.Title}'.
                Existing comments: {issue.Comments.Count(c => !c.User.Login.EndsWith("[bot]", StringComparison.Ordinal))}

                Here is the issue:
                {issue.Body}
                """));

            using var chatClient = OpenAIService.GetChat(model.Name, secondary: true);
            using var toolClient = new FunctionInvokingChatClient(chatClient);
            toolClient.AllowConcurrentInvocation = true;
            toolClient.MaximumIterationsPerRequest = 20;

            string markdownResponse = "";

            await foreach (var update in toolClient.GetStreamingResponseAsync(messages, options, cancellationToken))
            {
                markdownResponse += update.Text;

                MarkdownDocument document = MarkdownHelper.ParseAdvanced(markdownResponse);
                MarkdownHelper.FixUpPartialDocument(document);
                _htmlResponse = document.ToHtmlAdvanced();

                _ = InvokeAsync(StateHasChanged);
            }

            _htmlResponse = MarkdownHelper.ParseAdvanced(markdownResponse).ToHtmlAdvanced();
        }
        catch (OperationCanceledException) when (cancellationToken.IsCancellationRequested)
        {

        }
        catch (Exception ex)
        {
            _errorMessage = ex.Message;
        }
    }

    private async Task<IssueInfo> GetIssueAsync(int issueNumber, bool includeComments, CancellationToken cancellationToken)
    {
        await using GitHubDbContext db = GitHubDb.CreateDbContext();

        IQueryable<IssueInfo> query = db.Issues
            .AsNoTracking()
            .Where(i => i.Number == issueNumber)
            .Include(i => i.User)
            .Include(i => i.PullRequest)
            .Include(i => i.Labels)
            .Include(i => i.Repository);

        if (includeComments)
        {
            query = query.Include(i => i.Comments).ThenInclude(c => c.User);
        }

        return await query
            .AsSplitQuery()
            .FirstOrDefaultAsync(cancellationToken);
    }

    [Description("Get the full history of comments on a specific issue.")]
    private async Task<string[]> GetIssueCommentHistory(
        [Description("The issue number to get comments for.")] int issueNumber,
        CancellationToken cancellationToken)
    {
        IssueInfo issue = await GetIssueAsync(issueNumber, includeComments: true, cancellationToken);

        if (issue is null)
        {
            LogToolLine($"[Tool] Issue #{issueNumber} not found.");
            return ["No issue found."];
        }

        var comments = issue.Comments
            .OrderByDescending(c => c.CreatedAt)
            .Where(c => !SemanticMarkdownChunker.IsUnlikelyToBeUseful(issue, c))
            .Select(c => CreateCommentText(c.CreatedAt, c.User, c.Body, issue, c))
            .ToArray();

        int maxComments = UsingLargeContextWindow ? 200 : 50;

        if (comments.Length > maxComments)
        {
            comments = [.. comments.AsSpan(0, maxComments / 2), .. comments.AsSpan(comments.Length - (maxComments / 2))];
        }

        LogToolLine($"[Tool] Obtained {comments.Length} comments for issue #{issue.Number}: {issue.Title}");

        var originalIssue = CreateCommentText(issue.CreatedAt, issue.User, issue.Body, issue, comment: null);

        return [originalIssue, .. comments];
    }

    [Description("Perform a set of semantic searches over issues and comments. Every term represents an independent search.")]
    private async Task<string[]> Search(
        [Description("The set of terms to search for.")] string[] searchTerms,
        CancellationToken cancellationToken)
    {
        LogToolLine($"[Tool] Searching for {string.Join(", ", searchTerms)}");
        Stopwatch stopwatch = Stopwatch.StartNew();

        List<GitHubSearchService.IssueOrCommentSearchResult> searchResults = new();

        int maxTotalResults = UsingLargeContextWindow
            ? Math.Clamp(searchTerms.Length * 50, 75, 200)
            : Math.Clamp(searchTerms.Length * 25, 25, 50);
        int maxResultsPerTerm = searchTerms.Length > 1 ? (UsingLargeContextWindow ? 50 : 25) : maxTotalResults;

        await Parallel.ForEachAsync(searchTerms, async (term, _) =>
        {
            var localResults = await GitHubSearchService.SearchIssuesAndCommentsAsync(term, maxResultsPerTerm, cancellationToken);

            lock (searchResults)
            {
                searchResults.AddRange(localResults);
            }
        });

        searchResults = searchResults
            .Where(r => r.Score > 0.25)
            .DistinctBy(r => (r.Issue.Id, r.Comment?.Id ?? 0))
            .ToList();

        List<string> results = [];

        int issueReferences = 0;
        int searchIssues = 0;
        int searchComments = 0;

        foreach (string term in searchTerms)
        {
            if (GitHubHelper.TryParseIssueOrPRNumber(term, dotnetRuntimeOnly: true, out int issueNumber) &&
                await GetIssueAsync(issueNumber, includeComments: false, cancellationToken) is { } singleIssue)
            {
                issueReferences++;
                results.Add(GetComment(score: 1, singleIssue, singleIssue.CreatedAt, singleIssue.User, singleIssue.Body, comment: null));
            }
        }

        List<(string InfoText, double Score)> gitHubIssueResults = searchResults
            .Where(r => r.Issue.Id != _currentIssue?.Id)
            .Select(r =>
            {
                if (r.Comment is null)
                {
                    searchIssues++;
                }
                else
                {
                    searchComments++;
                }

                string issueResult = r.Comment is null
                    ? GetComment(r.Score, r.Issue, r.Issue.CreatedAt, r.Issue.User, r.Issue.Body, comment: null)
                    : GetComment(r.Score, r.Issue, r.Comment.CreatedAt, r.Comment.User, r.Comment.Body, r.Comment);

                return (issueResult, r.Score);
            })
            .ToList();

        results.AddRange(gitHubIssueResults
            .Where(r => !string.IsNullOrEmpty(r.InfoText))
            .OrderByDescending(r => r.Score)
            .Select(r => r.InfoText)
            .Take(maxTotalResults));

        LogToolLine($"[Tool] Found {searchIssues} issues, {searchComments} comments, {results.Count} returned results ({(int)stopwatch.ElapsedMilliseconds} ms)");

        return [.. results];

        string GetComment(double score, IssueInfo issue, DateTimeOffset createdAt, UserInfo author, string text, CommentInfo comment)
        {
            string issueSuffix = comment is not null ? "" : $"({issue.Comments.Count} total comments)";

            return
                $"""
                Simmilarity score: {score:F2}
                Issue #{issue.Number} - {issue.Title}{issueSuffix}:
                {CreateCommentText(createdAt, author, text, issue, comment)}
                """;
        }
    }

    private string CreateCommentText(DateTimeOffset createdAt, UserInfo author, string text, IssueInfo issue, CommentInfo comment)
    {
        string authorSuffix = s_networkingTeam.Contains(author.Login)
            ? $" (member of the .NET networking team)"
            : string.Empty;

        return
            $"""
            {author.Login}{authorSuffix} commented on {createdAt:yyyy-MM-dd}:
            {SemanticMarkdownChunker.TrimTextToTokens(GitHubSearchService.Tokenizer, text, 1_000)}

            {FormatReactions(issue, comment)}
            """.Trim(' ', '\t', '\n', '\r');

        static string FormatReactions(IssueInfo issue, CommentInfo comment)
        {
            string result = string.Empty;

            int positive =
                (comment?.Plus1 ?? issue.Plus1) +
                (comment?.Heart ?? issue.Heart) +
                (comment?.Hooray ?? issue.Hooray) +
                (comment?.Rocket ?? issue.Rocket);

            int negative =
                (comment?.Minus1 ?? issue.Minus1) +
                (comment?.Confused ?? issue.Confused);

            if (positive > 0)
            {
                result += $"Community upvotes: {positive}\n";
            }

            if (negative > 0)
            {
                result += $"Community downvotes: {negative}\n";
            }

            return result;
        }
    }

    public void Dispose()
    {
        _currentTriageCts?.Cancel();
    }
}
