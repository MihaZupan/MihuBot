@page "/runtime-notifications"
@using MihuBot.RuntimeUtils;
@using System.ComponentModel.DataAnnotations;
@inject RuntimeUtilsService runtimeUtils
@inject GitHubNotificationsService githubNotifications
@inject Logger Logger
@rendermode InteractiveServer

<PageTitle>Runtime notifications</PageTitle>
<h1>Runtime notifications</h1>

<AuthorizeView Policy="GitHub">
    <Authorized>
        <p>
            <small class="text-muted">Logged in as @@@_githubUserLogin</small>
        </p>

        @if (_currentUser is not null)
        {
            <p>PAT last updated on @_currentUser.PatUpdatedAt.ToISODate().</p>
            <p>Last subscribed issue: <a href="@_currentUser.LastSubscribedIssue">@_currentUser.LastSubscribedIssue</a></p>

            @if (_currentUser.Disabled)
            {
                <div class="alert alert-danger" role="alert">
                    Notifications are currently disabled. Please submit a new PAT.
                </div>
            }
        }

        <a href="https://github.com/settings/tokens/new?description=MihuBot-runtime-notifications&scopes=notifications">
            <strong>Create a new PAT here (adjust expiration as desired)</strong>
        </a>

        <br />
        <br />

        <EditForm Context="NewPATForm" Model="_newPat" OnValidSubmit="SubmitNewPATAsync">
            <DataAnnotationsValidator />
            <ValidationSummary />

            @if (!string.IsNullOrEmpty(_submittingPatError))
            {
                <div class="alert alert-danger" role="alert">
                    Failed to submit PAT: @_submittingPatError
                </div>
            }

            <div class="form-check">
                <InputText @bind-Value=_newPat.PAT placeholder="ghp_abc123" />
            </div>

            <br />
            <input disabled="@_submittingPat" type="submit" class="btn btn-primary" value="@(_submittingPat ? "Submitting ..." : "Submit new PAT")" />
        </EditForm>

        @if (_currentUser is not null)
        {
            <hr class="border-secondary opacity-50" />
            <h3>Options & subscriptions below are auto-saved. Rescans of old issues happen on a timer in the background.</h3>

            <div class="mb-3 form-check">
                <input class="form-check-input" type="checkbox" id="subscribeExisting"
                       checked="@_currentUser.SubscribeToExistingIssues"
                       @onchange="e => UpdateSubscribeToExistingIssuesAsync((bool)e.Value)" />
                <label class="form-check-label" for="subscribeExisting"><strong>Subscribe to existing issues</strong></label>
            </div>

            <div class="mb-3 form-check">
                <input class="form-check-input" type="checkbox" id="subscribeClosed"
                       checked="@_currentUser.SubscribeToClosedIssues"
                       @onchange="e => UpdateSubscribeToClosedIssuesAsync((bool)e.Value)" />
                <label class="form-check-label" for="subscribeClosed"><strong>Subscribe to closed issues</strong></label>
            </div>

            <table class="table table-dark">
                <thead>
                    <tr>
                        <th>Subscribe</th>
                        <th>Team</th>
                        <th>Area Labels</th>
                    </tr>
                </thead>
                <tbody>
                    @foreach (var team in githubNotifications.DotnetTeamToAreaLabel.OrderBy(t => t.Key, StringComparer.OrdinalIgnoreCase))
                    {
                        <tr>
                            <td>
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox"
                                           checked="@(_currentUser.Teams?.Contains(team.Key, StringComparer.OrdinalIgnoreCase) ?? false)"
                                           @onchange="e => UpdateUserTeamsAsync(team.Key, (bool)e.Value)" />
                                </div>
                            </td>
                            <td>@team.Key</td>
                            <td>
                                @foreach (var label in team.Value)
                                {
                                    <span class="badge bg-secondary mr-1">@label</span>
                                }
                            </td>
                        </tr>
                    }
                </tbody>
            </table>
        }
    </Authorized>
    <NotAuthorized>
        <a href="Account/Login/GitHub?returnUrl=%2Fruntime-notifications">
            <img src="github-mark.svg" />
            <strong style="font-size: 24px">Login with GitHub</strong>
        </a>
    </NotAuthorized>
</AuthorizeView>

@code
{
    private static readonly CooldownTracker s_validateCooldown = new(TimeSpan.FromMinutes(1), 10);

    [CascadingParameter]
    private Task<AuthenticationState> authenticationState { get; set; }

    private string _githubUserLogin;
    private GitHubNotificationsService.UserRecord _currentUser;

    private readonly NewPATModel _newPat = new();

    private bool _submittingPat;
    private string _submittingPatError;

    private class NewPATModel
    {
        [Required]
        [RegularExpression(
            pattern: @"^ghp_[a-zA-Z0-9]{20,100}$",
            ErrorMessage = "Invalid token format")]
        public string PAT { get; set; }
    }

    protected override async Task OnInitializedAsync()
    {
        if (authenticationState is not null &&
            (await authenticationState).User.TryGetGitHubLogin(out _githubUserLogin))
        {
            githubNotifications.TryGetUser(_githubUserLogin, out _currentUser);
        }

        StateHasChanged();
    }

    private async Task SubmitNewPATAsync()
    {
        _submittingPatError = null;
        _submittingPat = true;

        try
        {
            if (!s_validateCooldown.TryEnter((await authenticationState).User.GetGitHubUserId() ?? 0))
            {
                _submittingPatError = "Please wait a moment before submitting another PAT";
                return;
            }

            if (_currentUser?.Token == _newPat.PAT)
            {
                return;
            }

            Logger.DebugLog($"Testing PAT for {_githubUserLogin}");
            (bool valid, bool hasScopes) = await GitHubHelper.ValidatePatAsync(runtimeUtils.Http, _newPat.PAT, ["notifications"]);

            if (!valid)
            {
                _submittingPatError = "Invalid PAT";
                return;
            }

            if (!hasScopes)
            {
                _submittingPatError = "PAT does not have the required scopes (notifications)";
                return;
            }

            await githubNotifications.UpdatePATAsync(_githubUserLogin, _newPat.PAT);

            await OnInitializedAsync();
        }
        catch (Exception ex)
        {
            _submittingPatError = ex.ToString();
        }
        finally
        {
            _submittingPat = false;
        }
    }

    private async Task UpdateSubscribeToExistingIssuesAsync(bool value)
    {
        if (_currentUser is not null && _currentUser.SubscribeToExistingIssues != value)
        {
            _currentUser = _currentUser with { SubscribeToExistingIssues = value };
            await githubNotifications.UpdateUserRecordAsync(_currentUser);
            StateHasChanged();
        }
    }

    private async Task UpdateSubscribeToClosedIssuesAsync(bool value)
    {
        if (_currentUser is not null && _currentUser.SubscribeToClosedIssues != value)
        {
            _currentUser = _currentUser with { SubscribeToClosedIssues = value };
            await githubNotifications.UpdateUserRecordAsync(_currentUser);
            StateHasChanged();
        }
    }

    private async Task UpdateUserTeamsAsync(string group, bool value)
    {
        if (_currentUser is not null)
        {
            var teams = new HashSet<string>(_currentUser.Teams ?? [], StringComparer.OrdinalIgnoreCase);

            if (!(value ? teams.Add(group) : teams.Remove(group)))
            {
                return;
            }

            _currentUser = _currentUser with { Teams = teams.ToArray() };
            await githubNotifications.UpdateUserRecordAsync(_currentUser);
            StateHasChanged();
        }
    }
}

